\chapter{Exercises 3}

\section{Message integrity and authentication}

\textbf{Q1 - Which of the following ones are properties or characteristics of a one-way function?}
\begin{enumerate}
    \item[A.] \sol{converts an arbitrary length message into a fixed-length value (the digest)}
    \item[B.] \sol{given the digest value h(m), it should be computationally infeasible to find the corresponding message m}
    \item[C.] \sol{it should be impossible or infrequent to derive the same digest from two different messages}
    \item[D.] converts a fixed-length message to an arbitrary length value
\end{enumerate}

\textbf{Q2 - Assume Alice sends to Bob a plain message m along with its digest md=h(m) over an insecure channel. Assume Eve is an active attacker controlling the channel between Alice and Bob (i.e. can read, delete, modify, inject data). Bob receives both the message and the digest. What would tell Bob that the message has been modified?}
\begin{enumerate}
    \item[A.] the public key has been altered
    \item[B.] the message digest has been altered
    \item[C.] the message digest computed by Bob is different from the one sent by Alice
    \item[D.] the message extracted by Bob from the digest – i.e. $mBob=h^{-1}(md)$ – is different from the message received m
    \item[E.] \sol{none of the above}
\end{enumerate}
\com{Eve could delete Alice's messages and send Bob a new message with a new digest, usingthe same h function}


\textbf{Problem 1 - Alice wants to protect for integrity one file F on her disk (unprotected). She performs these steps: \\
\begin{enumerate}   
    \item[1.] she calculates a digest of the file, D = h(F)
    \item[2.] she copies D on a secure storage (e.g. a USB pen) where she also keeps other sensitive data (e.g. her RSA key-pair)
\end{enumerate} 
After one year, Alice wants to check if F has been illegally modified, so she takes the file F from disk and recalculates the digest on the file, D’ = h(F)\\}
\textbf{What would indicate to Alice that F has been modified?}
\begin{enumerate}
    \item[A.] the file F has a different creation time
    \item[B.] the private key has been altered
    \item[C.] \sol{the message digest D stored in the secure storage is different from the message digest D’ recalculated on F}
    \item[D.] the message digest D stored in the secure storage is the same as the message digest D’ recalculated on F
    \item[E.] none of the above
\end{enumerate}
\com{In this situation Eve can do nothing}

\textbf{Q3 - If different messages generate the same hash value, how is this called?}
\begin{enumerate}
    \item[A.] secure hashing
    \item[B.] \sol{collision}
    \item[C.] MAC generation
    \item[D.] HMAC generation
\end{enumerate}

\textbf{Q4 - Given a message m1, after 100,000 random attempts Alice finds a message m2 that generates the same hash value when calculated with the algorithm H. Is H a secure hash algorithm?}
\begin{enumerate}
    \item[A.] yes
    \item[B.] \sol{no}
    \item[C.] it depends on the length of the output generated by H
    \item[D.] it depends on the key used in the computation
\end{enumerate}
\com{Wikipedia: sha1 -> there is a 50\% chance of collision after 1.42x10^{24} records. So 10^{5} is not acceptable }

\textbf{Q5 - HMAC is an algorithm that allows:}
\begin{enumerate}
    \item[A.] \sol{to combine a message with a symmetric key to provide data authentication and integrity}
    \item[B.] to combine a message with an asymmetric private key to provide data authentication and integrity
    \item[C.] to combine a message with an asymmetric public key to provide data authentication and integrity
    \item[D.] to combine a message with a symmetric key to provide data authentication, integrity, and non-repudiation
    \item[E.] to combine a message with an asymmetric private key to provide data authentication, integrity, and non-repudiation
\end{enumerate}

\textbf{Q6 - Which of the following best describes the difference between HMAC and CBC-MAC?}
\begin{enumerate}
    \item[A.] HMAC creates a message digest and is used for integrity; CBC-MAC is used to encrypt blocks of data for confidentiality
    \item[B.] HMAC uses a symmetric key and a hash algorithm; CBC-MAC uses the first encrypted block as a checksum
    \item[C.] \sol{HMAC and CBC-MAC provide integrity and data authentication; HMAC uses a hash function, while CBC-MAC uses a block encryption algorithm}
    \item[D.] HMAC encrypts a message with a symmetric key and then puts the results through a hash algorithm; CBC-MAC encrypts the whole message
\end{enumerate}

\textbf{Q7 - Alice wants to protect some messages m1, m2, … mN for data authentication and integrity. She constructs for each message a MAC in the following manner:}
\textbf{\[for (i=1; i<=N; i++) \quad mac(i) = HMAC-SHA256( i, m_{i} );\]}
\textbf{She sends each message m_{i} and the corresponding mac(i)
to Bob over an unprotected channel.
Is data authentication and integrity achieved for all messages m_{i}? (justify your answer)}
\begin{enumerate}
    \item[A.] yes  
    \item[B.] \sol{no}
\end{enumerate}
\com{Look at Q2}

\textbf{Q8 - Alice wants to send Bob a plaintext P protected for confidentiality, authentication, and integrity \\
Alice and Bobs share two symmetric keys K1 and K2 \\
Alice and Bob agreed on two algorithms, A1 (for MAC) and A2 (for symmetric encryption)}
\begin{itemize}
    \item which operations should Alice perform on P and what data
    should she transmit to Bob so that he can recover the plaintext
    and verify its integrity and authenticity?
    \item explain the advantages and disadvantages of your solution 
\end{itemize}
\com{
\textbf{Solution}
Alice:
\begin{itemize}
    \item compute mac = A1(K1,P)
    \item compute C = A2-enc(K2,P)
    \item send to Bob (mac,C)
\end{itemize}
Advantages
\begin{itemize}
    \item full protection (P cannot be read/modified in transit)
\end{itemize}
Disadvantages
\begin{itemize}
    \item possible DoS (if data large and modified in transit) because decrypt needed before MAC verification
    \item MAC may leak information about P
\end{itemize}
}
\textbf{Q10  - Authenticated Encryption provides:}
\begin{enumerate}
    \item[A.] confidentiality and authentication/integrity in one step with two different keys
    \item[B.] \sol{confidentiality and authentication/integrity in one step with one key}
    \item[C.] confidentiality and authentication/integrity in two steps with one key
\end{enumerate}




\section{X.509v3 certificates, CRL, OCSP, digital signatures}

\textbf{Q1 - Which of the following best describes a Certification Authority?}
\begin{enumerate}
    \item[A.] an organization that issues private keys and the corresponding algorithms
    \item[B.] an organization that certifies encryption algorithms
    \item[C.] an organization that certifies encryption keys
    \item[D.] \sol{an organization that issues public-key certificates to entities}
\end{enumerate}

\textbf{Q3 - Assume a CA issues an X.509v3 certificate to Alice. Which of the following values are included in the certificate issued to Alice? Select all that apply.}
\begin{itemize}
    \item[A.] \sol{Alice’s public key}
    \item[B.] Alice’s private key
    \item[C.] \sol{A signature on Alice’s X.509v3 certificate, calculated with the CA’s private key}
    \item[D.] A signature of the Alice’s X.509v3 certificate, calculated with the CA’s public key
    \item[E.] \sol{An indication of the owner of the certificate, such as the Alice’s name or e-mail address}
    \item[F.] \sol{A time period, indicating the lifetime of the certificate}
    \item[G.] \sol{An indication of the issuer of the certificate, such as the CA’s name}
\end{itemize}

\textbf{Q4 - Why would a Certification Authority revoke a certificate?}
\begin{enumerate}
    \item[A.] if the subject’s public key has been compromised
    \item[B.] \sol{if the subject’s private key has been compromised}
    \item[C.] if the subject sent the certificate over an unprotected channel
    \item[D.] none of the above
\end{enumerate}

\textbf{Q5 - Which of the following statements about CRL and OCSP are correct?}
\begin{enumerate}
    \item[A.] \sol{CRL is a list of revoked certificates issued by a CA}
    \item[B.] CRL is a list of revoked certificates issued by a root CA
    \item[C.] OCSP is a protocol to query a server about the validity of a single specific certificate at a specified time
    \item[D.] \sol{OCSP is a protocol to query a server about the validity of a single specific certificate at the current time}
\end{enumerate}
\com{B -> is not necessary root CA\\C -> used for real-time checks }

\textbf{Q6 - Alice sends a digitally signed message to Bob and attaches her X.509v3 certificate (and a certificate chain up to a trusted root CA).
 Which steps must Bob perform to verify the signature on the message? (you can select multiple responses from the ones below)}
\begin{itemize}
    \item[A.] \sol{verify the signature on the message by using the certificate of Alice}
    \item[B.] \sol{verify that the certificate of Alice is authentic by constructing the chain up to a trusted root and verifying the signatures on each certificate in the chain}
    \item[C.] \sol{verify that each certificate in the chain (except the one of the trusted root) has not been revoked}
    \item[D.] \sol{do not check the trusted root CA certificate that Alice sent him because he should have it already configured it as trusted}
\end{itemize}

\section{Exercises - Message integrity & asymmetric crypto}

\textbf{E1a - Alice wants to send to Bob a message P protected for integrity and (data) authentication}
\begin{itemize}
    \item Alice and Bob share a symmetric key K
    \item Alice and Bob agreed about using HMAC-SHA1
\end{itemize}
\textbf{what information should Alice send to Bob? (write the corresponding formulas)\\}
\com{
\textbf{Solution}
Alice
\begin{itemize}
    \item mac = HMAC-SHA1(K,P)
    \item Alice send Bob (mac,P) \textcolor{Comment}{Mac sent first because fixed length}
\end{itemize}
Bob
\begin{itemize}
    \item receive (mac,P)
    \item mac' = HMAC-SHA1(K,P)
    \item if(mac!=mac') then FAIL; else OK
\end{itemize}
}
\textbf{E1b - Alice wants to send to Bob a message P protected for integrity and (data) authentication}
\begin{itemize}
    \item Alice and Bob share a symmetric key K
    \item Alice and Bob agreed about using HMAC
\end{itemize}
\textbf{what information should Alice send to Bob? (write the corresponding formulas)\\}
\com{
\textbf{Solution}
Alice
\begin{itemize}
    \item select one hash algorithm (SHA256)
    \item mac = HMAC-SHA256(K, P||"SHA256")
    \item send Bob ("SHA256",mac,P)
\end{itemize}
Bob
\begin{itemize}
    \item receive(algorithm,mac,P)
    \item mac' = HMAC-algorithm(K,P||algorithm) 
    \item if(mac!=mac') then FAIL; else OK
\end{itemize}
%\textcolor{Comment}{"if an attacker changes the algorithm Bob can't verify it". (WIP) i don't like this, if an attacker changes everything everytime Bob will never be able to verify anything,  so wtf are we talking about?}

}

\textbf{E2 - Alice wants to send a confidential message P to Bob … and}
\begin{itemize}
    \item P is large, e.g. 10 GB
    \item P must be protected for 4 months 
\end{itemize}
\textbf{Alice and Bob have agreed about an asymmetric encryption algorithm (RSA), and a symmetric one (AES-128-CBC) and exchanged OOB their respective public keys
\\ write the formulas and the steps\\}
\com{
\textbf{Solution}
Alice
\begin{itemize}
    \item generate a secret key K = random(128bit) 
    \item generate IV = random(128) \textcolor{Comment}{equal to block length, and must be random/never reused under the same key}
    \item compute EK = RSA-enc(Bob.PK, K) \textcolor{Comment}{encrypted shared key, with Bob public key} 
    \item compute C = AES-128-CBC-enc(K,IV,P)
    \item send Bob (IV,EK,C)
\end{itemize}
Bob
\begin{itemize}
    \item receive (IV,EK,C)
    \item compute K = RSA-dec(Bob.SK, EK) \textcolor{Comment}{decrypt the shared key, with his (Bob) private/\underline{\textbf{s}ecret key}}
    \item compute P = AES-128-CBC-dec(K,IV,C)
\end{itemize}
}

\textbf{E3 - Alice wants to send to Bob a digitally signed message P}
\textbf{assumptions:}
\begin{itemize}
    \item Alice has an RSA key pair ( Alice.SK, Alice.PK )
    \item Bob knows Alice.PK (may be it was exchanged OOB)
\end{itemize}
\textbf{write down the formulas}
\com{
\textbf{Solution}
Alice 
\begin{itemize}
    \item H =  SHA-256(P||"RSA"||"SHA-256")
    \item sig = RSA-2048(Alice.SK, H)
    \item send Bob ("RSA","SHA-256",sig,P)
\end{itemize}
Bob
\begin{itemize}
    \item receive ("RSA","SHA-256",sig,P)
    \item H = RSA-2048(Alice.PK, sig)
    \item H' = SHA-256(P||"RSA"||"SHA-256")
    \item if H==H' OK else fail
\end{itemize}
Often algorithm for hash and signature creation are specified together, "sha256WithRSAEncryption"
}
\textbf{Problem - Two companies in business wish to protect their messages
(exchanged via an unprotected TCP/IP network) by
providing confidentiality, integrity, and data authentication.
Assuming that the companies do not have access to any
secure channel or data format but share a password pwd
(10 alphanumeric characters long) and can use only basic
symmetric encryption, hash algorithms, and auxiliary
mathematical functions (but not asymmetric encryption),
suggest a possible solution for protecting a message M and
write the formula to generate the protected message P.\\}

\com{
ideas
\begin{itemize}
    \item generate a shared key from the password with the PBKDF
    \item use HMAC for data authentication and integrity (SHA256)
    \item use symmetric encryption (AES-128-CBC) for confidentiality
    \item choose Encrypt-then-authenticate (EtA) (so two keys are needed!!!)-> enc(K1,P)||mac(K2,enc(K1,P))
\end{itemize}
formulas
\begin{itemize}
    \item salt1 = random(16bit)
    \item salt2 = random(16bit)
    \item K1 = PBKDF2(HMAC-SHA256, pwd, salt1, 4096, 128) \textcolor{Comment}{4096 n iterations, 128 desired length}
    \item K2 = PBKDF2(HMAC-SHA256, pwd, salt2, 4096, 128)
    \item IV = random(128bit)
    \item C = AES-128-CBC-enc(K1, IV, M)
    \item mac = HMAC-SHA256(K2,C)
    \item P = IV || C || mac
\end{itemize}
We have tu send the salt in order for the other company to regenerate the same keys\\
we should protect the IV, it's integrity is not covered by the mac, and could lead to a DoS attack. If an attacker changes it,  
Bob compute the mac with no errors, but i will not decrypt it correctly. REMEMBER an hash function is faster than a enc/dec function. We 'cannot' afford
to waste time\\ 
we should have attached the algorithm used in C too, and we have to protect its integrity.
formulas
\begin{itemize}
    \item salt1 = random(128bit)
    \item salt2 = random(128bit)
    \item K1 = PBKDF2(HMAC-SHA256, pwd, salt1, 4096, 128) \textcolor{Comment}{4096 n iterations, 128 desired length}
    \item K2 = PBKDF2(HMAC-SHA256, pwd, salt2, 4096, 128)
    \item IV = random(128bit)
    \item C = AES-128-CBC-enc(K1, IV, M)
    \item C' = "AES-128-CBC"||"HMAC-SHA256"||C||IV||salt1||salt2
    \item mac = HMAC-SHA256(K2,C')
    \item P = C' || mac
\end{itemize}
If the MAC fails to recompute, decryption is unnecessary.
}

\section{Authentication}
\textbf{Q1 - Which of the following statements correctly describes reusable passwords as an authentication factor?}
\begin{enumerate}
    \item[A.] they are the least expensive and most secure
    \item[B.] they are the most expensive and least secure
    \item[C.] \sol{they are the least expensive and least secure}
    \item[D.] they are the most expensive and most secure
\end{enumerate}

\textbf{Q2 - Which of the following factors provides stronger authentication?}
\begin{enumerate}
    \item[A.] what a person knows
    \item[B.] \sol{what a person is}
    \item[C.] what a person has
\end{enumerate}

\textbf{Q3 - How is a challenge/response protocol used with an authentication-token (device)?}
\begin{enumerate}
    \item[A.] this protocol is not used; cryptography is used
    \item[B.] \sol{an authentication service generates a challenge, then the authentication token generates a response based on the challenge}
    \item[C.] the token challenges the user for a username and password
    \item[D.] the token challenges the user’s password against a database of stored credentials
\end{enumerate}

\textbf{Q4 - What is a dictionary attack?}
\begin{enumerate}
    \item[A.] \sol{the attacker pre-computes a list of hashes of many "words"; the hashes are then compared with a hashed password (sniffed from the communication channel or leaked from a server)}
    \item[B.] the attacker pre-computes several hashes (for several iterations) starting from a word in the Dictionary; the hashes are then compared with a hashed password (sniffed from the communication channel or leaked from a server)
    \item[C.] the attacker uses a Dictionary of common words (e.g. English language dictionary) to pre-compute a big list of their hashes; the hashes are then compared with a hashed password (sniffed from the communication channel or leaked from a server)
\end{enumerate}
\com{B -> we assume an attacker knows the hash algorithm (H) and a pwd hash value, than apply H to all the words in his dictionary\\
C -> use more Dictionary}

\textbf{Q5 - A salt is used to protect from dictionary attack. A salt is ..}
\begin{enumerate}
    \item[A.] a secret number
    \item[B.] \sol{a random number, unpredictable}
    \item[C.] a number that must be known only by the user to generate a more secure password
\end{enumerate}
\com{To avoid dictionary we append a salt to the pwd, so the hash will never be in a pre-computes list}

\textbf{Q6 - The advantages of static passwords are (you can choose more than one option):}
\begin{enumerate}
    \item[A.] \sol{are simple, "free", and require no extra device to carry}
    \item[B.] are immune to sniffing
    \item[C.] are immune to replay attacks
    \item[D.] \sol{require no trust in a third party (in contrast, public key certificates require trust in the CA)}
    \item[E.] are immune to MITM attacks
\end{enumerate}
\com{B,C,E -> one sniffed i can reuse it (without decrypt it) for access the victim account }

\textbf{Q7 - The advantages of OTPs are (you can choose more than one option):}
\begin{enumerate}
    \item[A.] are simple, "free", and require no extra device to carry
    \item[B.] \sol{sniffing attacks are not efficient}
    \item[C.] \sol{are immune to replay attacks}
    \item[D.] require no trust in a third party (in contrast, public key certificates require trust in the CA) 
    \item[E.] are immune to MITM attacks
\end{enumerate}
\com{a MITM can still manipulates the packets, \\ D -> Correct if formulated differently, we have to trust the producer of the device}

\textbf{Q8 - A claimant must authenticate to a Verifier by using a symmetric CRA protocol. The advantages in this case are (you can choose multiple options):}
\begin{enumerate}
    \item[A.] the Verifier must not store sensitive keys
    \item[B.] \sol{sniffing attacks are not efficient}
    \item[C.] \sol{replay attacks cannot be performed}
    \item[D.] \sol{require no trust in a third party (in contrast, public key certificates require trust in the CA) or OOB exchange of public keys}
    \item[E.] \sol{is fast}
    \item[F.] is immune to involuntary signing or to relay attacks (does not require Verifier authentication)
\end{enumerate}

\textbf{Q9 - A claimant must authenticate to a Verifier by using an asymmetric CRA protocol. The advantages in this case are (you can choose multiple options):}
\begin{enumerate}
    \item[A.] \sol{the Verifier must not store sensitive keys}
    \item[B.] \sol{sniffing attacks are not efficient}
    \item[C.] \sol{replay attacks cannot be performed}
    \item[D.] require no trust in a third party (in contrast, public key certificates require trust in the CA) or OOB exchange of public keys
    \item[E.] is fast
    \item[F.] is immune to involuntary signing or relay attacks (does not require Verifier authentication)
\end{enumerate}
\com{
    A -> since the claimant sand is public key and certificate\\
    B,C -> encryption and authentication\\
    D -> CA certificate, PKI\\
    E -> asymmetric cryptography is slower\\
    F -> in relay attack a MITM start the comunication sending the Verifier the 'claimant' ID and PB.K }
